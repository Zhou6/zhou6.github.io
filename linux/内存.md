## 内存
内存以页为单位的管理方式。在分页的基础上，虚拟内存和物理内存实现了分离，从而让内核深度参与和监督内存分配。
### 物理内存

内存有一个最小的存储单位，大多数都是一个字节。内存用内存地址（memory address）来为每个字节的数据顺序编号。因此，内存地址说明了数据在内存中的位置。内存地址从0开始，每次增加1。这种线性增加的存储器地址称为线性地址（linear address）。为了方便，我们用十六进制数来表示内存地址，比如0x00000003、0x1A010CB0。这里的“0x”用来表示十六进制。“0x”后面跟着的，就是作为内存地址的十六进制数。

内存地址的编号有上限。地址空间的范围和地址总线（address bus）的位数直接相关。CPU通过地址总线来向内存说明想要存取数据的地址。以英特尔32位的80386型CPU为例，这款CPU有32个针脚可以传输地址信息。每个针脚对应了一位。如果针脚上是高电压，那么这一位是1。如果是低电压，那么这一位是0。32位的电压高低信息通过地址总线传到内存的32个针脚，内存就能把电压高低信息转换成32位的二进制数，从而知道CPU想要的是哪个位置的数据。用十六进制表示，32位地址空间就是从0x00000000 到0xFFFFFFFF。CPU是通过寻址来访问内存的。32位CPU的寻址宽度是 0~0xFFFFFFFF ，计算后得到的大小是4G，也就是说可支持的物理内存最大是4G。

内存的存储单元采用了随机读取存储器（RAM， Random Access Memory）。所谓的“随机读取”，是指存储器的读取时间和数据所在位置无关。与之相对，很多存储器的读取时间和数据所在位置有关。就拿磁带来说，我们想听其中的一首歌，必须转动带子。如果那首歌是第一首，那么立即就可以播放。如果那首歌恰巧是最后一首，我们快进到可以播放的位置就需要花很长时间。我们已经知道，进程需要调用内存中不同位置的数据。如果数据读取时间和位置相关的话，计算机就很难把控进程的运行时间。因此，随机读取的特性是内存成为主存储器的关键因素。

内存提供的存储空间，除了能满足内核的运行需求，还通常能支持运行中的进程。即使进程所需空间超过内存空间，内存空间也可以通过少量拓展来弥补。换句话说，内存的存储能力，和计算机运行状态的数据总量相当。内存的缺点是不能持久地保存数据。一旦断电，内存中的数据就会消失。因此，计算机即使有了内存这样一个主存储器，还是需要硬盘这样的外部存储器来提供持久的储存空间。

### 虚拟内存
内存的一项主要任务，就是存储进程的相关数据。我们之前已经看到过进程空间的程序段、全局数据、栈和堆，以及这些这些存储结构在进程运行中所起到的关键作用。有趣的是，尽管进程和内存的关系如此紧密，但进程并不能直接访问内存。在Linux下，进程不能直接读写内存中地址为0x1位置的数据。进程中能访问的地址，只能是虚拟内存地址（virtual memory address）。操作系统会把虚拟内存地址翻译成真实的内存地址。这种内存管理方式，称为虚拟内存（virtual memory）。

每个进程都有自己的一套虚拟内存地址，用来给自己的进程空间编号。进程空间的数据同样以字节为单位，依次增加。从功能上说，虚拟内存地址和物理内存地址类似，都是为数据提供位置索引。进程的虚拟内存地址相互独立。因此，两个进程空间可以有相同的虚拟内存地址，如0x10001000。虚拟内存地址和物理内存地址又有一定的对应关系。

应用程序来说对物理内存地址一无所知。它只可能通过虚拟内存地址来进行数据读写。程序中表达的内存地址，也都是虚拟内存地址。进程对虚拟内存地址的操作，会被操作系统翻译成对某个物理内存地址的操作。由于翻译的过程由操作系统全权负责，所以应用程序可以在全过程中对物理内存地址一无所知。python中的id()获取的就是虚拟内存地址。

借助虚拟内存地址，操作系统可以保障进程空间的独立性。只要操作系统把两个进程的进程空间对应到不同的内存区域，就让两个进程空间成为“老死不相往来”的两个小王国。两个进程就不可能相互篡改对方的数据，进程出错的可能性就大为减少。

另一方面，有了虚拟内存地址，内存共享也变得简单。操作系统可以把同一物理内存区域对应到多个进程空间。这样，不需要任何的数据复制，多个进程就可以看到相同的数据。内核和共享库的映射，就是通过这种方式进行的。每个进程空间中，最初一部分的虚拟内存地址，都对应到物理内存中预留给内核的空间。这样，所有的进程就可以共享同一套内核数据。共享库的情况也是类似。对于任何一个共享库，计算机只需要往物理内存中加载一次，就可以通过操纵对应关系，来让多个进程共同使用。IPO中的共享内存，也有赖于虚拟内存地址。
### 内存页
虚拟内存地址和物理内存地址的分离，给进程带来便利性和安全性。但虚拟内存地址和物理内存地址的翻译，又会额外耗费计算机资源。在多任务的现代计算机中，虚拟内存地址已经成为必备的设计。那么，操作系统必须要考虑清楚，如何能高效地翻译虚拟内存地址。

记录对应关系最简单的办法，就是把对应关系记录在一张表中。为了让翻译速度足够地快，这个表必须加载在内存中。不过，这种记录方式惊人地浪费。如果树莓派1GB物理内存的每个字节都有一个对应记录的话，那么光是对应关系就要远远超过内存的空间。由于对应关系的条目众多，搜索到一个对应关系所需的时间也很长。这样的话，会让树莓派陷入瘫痪。

因此，Linux采用了分页（paging）的方式来记录对应关系。所谓的分页，就是以更大尺寸的单位页（page）来管理内存。在Linux中，通常每页大小为4KB。

内存分页，可以极大地减少所要记录的内存对应关系。我们已经看到，以字节为单位的对应记录实在太多。如果把物理内存和进程空间的地址都分成页，内核只需要记录页的对应关系，相关的工作量就会大为减少。由于每页的大小是每个字节的4000倍。因此，内存中的总页数只是总字节数的四千分之一。对应关系也缩减为原始策略的四千分之一。分页让虚拟内存地址的设计有了实现的可能。

虚拟地址和物理地址的组成是前一部分为页编号，后一部分为在本页的偏移量。

无论是虚拟页，还是物理页，一页之内的地址都是连续的。这样的话，一个虚拟页和一个物理页对应起来，页内的数据就可以按顺序一一对应。这意味着，虚拟内存地址和物理内存地址的末尾部分应该完全相同。大多数情况下，每一页有4096个字节。由于4096是2的12次方，所以地址最后12位的对应关系天然成立。我们把地址的这一部分称为偏移量（offset）。偏移量实际上表达了该字节在页内的位置。地址的前一部分则是页编号。操作系统只需要记录页编号的对应关系。

因为内存映射设备会在内存页的层面工作，所以操作系统认为内存分配的最小单元就是虚拟页。哪怕用户程序只是申请了 1 字节的内存，操作系统也会为它申请一个虚拟页。
   #### 大内存页（hugepage）
   
   “大内存页”有助于 Linux 系统进行虚拟内存管理。顾名思义，除了标准的 4KB 大小的页面外，它们还能帮助管理内存中的巨大的页面。使用“大内存页”，2MB 一般都是 HugePages 的默认大小，你最大可以定义 1GB 的页面大小。
    
   在虚拟内存管理中，内核维护一个将虚拟内存地址映射到物理地址的表，对于每个页面操作，内核都需要加载相关的映射。如果你的内存页很小，那么你需要加载的页就会很多，导致内核会加载更多的映射表。而这会降低性能。

   使用“大内存页”，意味着所需要的页变少了。从而大大减少由内核加载的映射表的数量。这提高了内核级别的性能最终有利于应用程序的性能。
   
   HugePages 与其他内存页不同，它是由系统工程师预先在操作系统上使用命令分配的，当进程通过 mmap 或者其他系统调用申请大页时，它们得到的都是预先分配的资源。Linux 中的 HugePages 都被锁定在内存中，所以哪怕是在系统内存不足时，它们也不会被 Swap 到磁盘上，这也就能从根源上杜绝了重要内存被频繁换入和换出的可能6。

简而言之，通过启用“大内存页”，系统具只需要处理较少的页面映射表，从而减少访问/维护它们的开销！
### 多级分页表
内存分页制度的关键，在于管理进程空间页和物理页的对应关系。操作系统把对应关系记录在分页表（page table）中。这种对应关系让上层的抽象内存和下层的物理内存分离，从而让Linux能灵活地进行内存管理。由于每个进程会有一套虚拟内存地址，那么每个进程都会有一个分页表。为了保证查询速度，分页表也会保存在内存中。分页表有很多种实现方式，最简单的一种分页表就是把所有的对应关系记录到同一个线性列表中。

这种单一的连续分页表，需要给每一个虚拟页预留一条记录的位置。但对于任何一个应用进程，其进程空间真正用到的地址都相当有限。我们还记得，进程空间会有栈和堆。进程空间为栈和堆的增长预留了地址，但栈和堆很少会占满进程空间。这意味着，如果使用连续分页表，很多条目都没有真正用到。因此，Linux中的分页表，采用了多层的数据结构。多层的分页表能够减少所需的空间，即把之前的页地址拆分为两个或更多的部分，然后用两层或更多层的分页表来记录其对应关系。

假如页编号分成了两级。第一级对应了前8位页编号，用2个十六进制数字表示。第二级对应了后12位页编号，用3个十六进制编号。二级表记录有对应的物理页，即保存了真正的分页记录。二级表有很多张，每个二级表分页记录对应的虚拟地址前8位都相同。比如二级表0x00，里面记录的前8位都是0x00。翻译地址的过程要跨越两级。我们先取地址的前8位，在一级表中找到对应记录。该记录会告诉我们，目标二级表在内存中的位置。我们再在二级表中，通过虚拟地址的后12位，找到分页记录，从而最终找到物理地址。

多层分页表还有另一个优势。单层分页表必须存在于连续的内存空间。而多层分页表的二级表，可以散步于内存的不同位置。这样的话，操作系统就可以利用零碎空间来存储分页表。还需要注意的是，这里简化了多层分页表的很多细节。最新Linux系统中的分页表多达3层，管理的内存地址也比本章介绍的长很多。不过，多层分页表的基本原理都是相同。

常见的配置是4级页表，就以4级页表为例说明。分别是PGD、PUD、PMD、PTE四级页表。PTE页表中存储物理地址
### swap
Swap分区（即交换区）在系统的物理内存不够用的时候，把硬盘空间中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。

### 缺页中断
malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。

缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。

缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：
1. 保护CPU现场
2. 分析中断原因
3. 转入缺页中断处理程序进行处理
4. 恢复CPU现场，继续执行

但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：
1. 在指令执行期间产生和处理缺页中断信号
2. 一条指令在执行期间，可能产生多次缺页中断
3. 缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。

### slab
待补充
### MMU
内存管理单元（英语：memory management unit，缩写为MMU），有时称作分页内存管理单元（英语：paged memory management unit，缩写为PMMU）。它是一种负责处理中央处理器（CPU）的内存访问请求的计算机硬件。它的功能包括虚拟地址到物理地址的转换（即虚拟内存管理）、内存保护、中央处理器高速缓存的控制，在较为简单的计算机体系结构中，负责总线的仲裁以及存储体切换（bank switching，尤其是在8位的系统上）。

借助一种叫做转译旁观缓冲器（Translation Lookaside Buffer，缩写为TLB）的相联高速缓存（associative cache）来将虚拟页号转换为物理页号
### TLB
待补充
### 查看内存的方式
1. maps

    cat /proc/{pid}/maps显示某进程映射了的内存区域和访问权限。
    对应内核中的操作集为proc_pid_maps_op，具体的导出函数为show_map。内核中进程的一段地址空间用一个vm_area_struct结构体表示，所有地址空间存储在task->mm->mmap链表中。
    
    一个文件可以映射到进程的一段内存区域中，映射的文件描述符保存在vm_area_struct->vm_file域中，这种内存区域叫做有名内存区域，相反，属于匿名映射内存区域。Vm_area_struct每项对应解析如下表所示：
    “-”前一列：此段虚拟地址空间起始地址
    
    “-”后一列：此段虚拟地址空间结束地址
    
    第三列,如r-xp：此段虚拟地址空间的属性。每种属性用一个字段表示，r表示可读，w表示可写，x表示可执行，p和s共用一个字段，互斥关系，p表示私有段，s表示共享段，如果没有相应权限，则用’-’代替
    
    第四列，如00000000：对有名映射，表示此段虚拟内存起始地址在文件中以页为单位的偏移。对匿名映射，它等于0或者vm_start/PAGE_SIZE
    
    第五列，如fd:00：映射文件所属设备号。对匿名映射来说，因为没有文件在磁盘上，所以没有设备号，始终为00:00。对有名映射来说，是映射的文件所在设备的设备号
    
    第六列，如2719760：映射文件所属节点号。对匿名映射来说，因为没有文件在磁盘上，所以没有节点号，始终为00:00。对有名映射来说，是映射的文件的节点号
    
    第七列，如/lib/ld-2.5.so：对有名来说，是映射的文件名。对匿名映射来说，是此段虚拟内存在进程中的角色。[stack]表示在进程中作为栈使用，[heap]表示堆。其余情况则无显示
    
    例子：
        
        001f7000-00212000 r-xp 00000000 fd:00 2719760    /lib/ld-2.5.so
        00212000-00213000 r-xp 0001a000 fd:00 2719760    /lib/ld-2.5.so
        00213000-00214000 rwxp 0001b000 fd:00 2719760    /lib/ld-2.5.so
2. smaps

    cat /proc/{pid}/smaps: 是基于 /proc/PID/maps 的扩展，他展示了一个进程的内存消耗，比同一目录下的maps文件更为详细。
    
    例子：
    
        08048000-080bc000 r-xp 00000000 03:02 13130      /bin/bash    # 第一行的信息完全同于在maps文件中输出的信息
        Size:               1084 kB  # 虚拟内存空间大小。但是这个内存值不一定是物理内存实际分配的大小，因为在用户态上，虚拟内存总是延迟分配的。这个值计算也非常简单，就是该VMA的开始位置减结束位置。
        Rss:                 892 kB  # 是实际分配的内存，这部分物理内存已经分配，不需要缺页中断就可以使用的。 Rss=Shared_Clean+Shared_Dirty+Private_Clean+Private_Dirty
        Pss:                 374 kB  # 是平摊计算后的实际物理使用内存(有些内存会和其他进程共享，例如mmap进来的)。实际上包含下面private_clean+private_dirty，和按比例均分的shared_clean、shared_dirty。
        Shared_Clean:        892 kB  # 共享且未被修改
        Shared_Dirty:          0 kB  # 共享已被修改过。在页面被淘汰的时候，就会把该脏页面回写到交换分区（换出，swap out）
        Private_Clean:         0 kB  # 私有且未被修改
        Private_Dirty:         0 kB  # 私有已被修改过
        Referenced:          892 kB  # 当前页面被标记为已引用或者包含匿名映射。当某个页面被访问后，Referenced标志被设置，如果该标志设置了，就不能将该页移出
        Anonymous:             0 kB  # 匿名映射的物理内存，这部分内存不来自于文件的内存大小。
        ShmemPmdMapped:        0 kB  # PMD页面已经被映射的共享（shmem / tmpfs）内存量
        Shared_Hugetlb:        0 kB  # 由共享hugetlbfs页面支持的内存使用量，由于历史原因，该页面未计入“ RSS”或“ PSS”字段中。 并且这些没有包含在Shared/Private_Clean/Dirty 字段中。
        Private_Hugetlb:       0 kB  # 私有hugetlbfs页面支持的内存使用量
        Swap:                  0 kB  # 存在于交换分区的数据大小
        SwapPss:               0 kB  # 类似pss，只不过此处针对交换分区的内存
        KernelPageSize:        4 kB  # 内核一页的大小
        MMUPageSize:           4 kB  # MMU页大小，大多数情况下，和KernelPageSize大小一样。
        Locked:                0 kB  # 常驻物理内存的大小，这些页不会被换出
        THPeligible:           0     # 映射是否符合分配THP（透明大页）的条件。如果为true，则为1，否则为0。 它仅显示当前状态。
        VmFlags: rd ex mr mw me dw   # 表示与特定虚拟内存区域关联的内核标志
    
    - 延迟分配：
    
        当进程申请内存的时候，Linux会给他先分配页，但是并不会区建立页与页框的映射关系，意思就是说并不会分配物理内存，而当真正使用的时候，就会产生一个缺页异常，硬件跳转page fault处理程序执行，在其中分配物理内存，然后修改页表(创建页表项)。异常处理完毕，返回程序用户态，继续执行。
    - share/private/dirty/clean 计算逻辑：
    
        查看该page的引用数，如果引用>1，则归为shared，如果是1，则归为private，同时也查看该page的flag，是否标记为_PAGE_DIRTY，如果不是，则认为干净的。
    - THP，透明大页（Transparent Huge Pages）：
    
        RHEL 6 开始引入，目的是使用更大的内存页面（memory page size） 以适应越来越大的系统内存，让操作系统可以支持现代硬件架构的大页面容量功能。与标准大页的区别在于分配机制，标准大页管理是预分配的方式，而透明大页管理则是动态分配的方式。
    - VmFlags标志：
    
          rd  - readable
          wr  - writeable
          ex  - executable
          sh  - shared
          mr  - may read
          mw  - may write
          me  - may execute
          ms  - may share
          gd  - stack segment growns down
          pf  - pure PFN range
          dw  - disabled write to the mapped file
          lo  - pages are locked in memory
          io  - memory mapped I/O area
          sr  - sequential read advise provided
          rr  - random read advise provided
          dc  - do not copy area on fork
          de  - do not expand area on remapping
          ac  - area is accountable
          nr  - swap space is not reserved for the area
          ht  - area uses huge tlb pages
          ar  - architecture specific flag
          dd  - do not include area into core dump
          sd  - soft-dirty flag
          mm  - mixed map area
          hg  - huge page advise flag
          nh  - no-huge page advise flag
          mg  - mergable advise flag
3. status
    
    cat /proc/{pid}/status
    例子
    
        Name:   systemd                   # 可执行程序的名字                                                                                                                                           
        Umask:  0000                                                                                                                                                           
        State:  S (sleeping)              # 任务状态，运行/睡眠/僵死                                                                                                                                     
        Tgid:   1                         # 线程组号                                                                                                                                     
        Ngid:   0                                                                                                                                                              
        Pid:    1                         # 进程id                                                                                                                                     
        PPid:   0                         # 父进程id                                                                                                                                     
        TracerPid:      0                 # 跟踪当前进程的进程ID,如果是0,表示没有跟踪.                                                                                                                                     
        Uid:    0       0       0       0                                                                                                                                      
        Gid:    0       0       0       0                                                                                                                                      
        FDSize: 128                       # 该进程最大文件描述符个数,当前分配的文件描述符,这个值不是当前进程使用文件描述符的上限,会涨但是不会降                                                                                                                      
        Groups:                                                                                                                                                                
        NStgid: 1                                                                                                                                                              
        NSpid:  1                                                                                                                                                              
        NSpgid: 1                                                                                                                                                              
        NSsid:  1                                                                                                                                                              
        VmPeak:   235180 kB               # 内存使用峰值                                                                                                                                     
        VmSize:   170900 kB               # 进程虚拟地址空间大小                                                                                                                                     
        VmLck:         0 kB               # 进程锁住的物理内存大小，锁住的物理内存无法交换到硬盘                                                                                                                                     
        VmPin:         0 kB               
        VmHWM:     10300 kB               # 得到分配的物理内存的峰值
        VmRSS:      6252 kB               # 进程正在使用的物理内存大小
        RssAnon:            2904 kB
        RssFile:            3348 kB
        RssShmem:              0 kB
        VmData:    18792 kB               # 进程数据段大小
        VmStk:      1036 kB               # 进程用户态栈大小
        VmExe:       892 kB               # 进程代码段大小
        VmLib:      8396 kB               # 进程使用的库映射到虚拟内存空间的大小
        VmPTE:       100 kB               # 进程页表大小
        VmSwap:        0 kB               # 进程占用Swap的大小
        HugetlbPages:          0 kB
        CoreDumping:    0
        Threads:        1                 # 当前进程有几个线程
        SigQ:   0/31795                   # 表示当前待处理信号的个数
        SigPnd: 0000000000000000          # 屏蔽位,存储了该线程的待处理信号,等同于线程的PENDING信号
        ShdPnd: 0000000000000000          # 屏蔽位,存储了该线程组的待处理信号.等同于进程组的PENDING信号
        SigBlk: 7be3c0fe28014a03          # 存放被阻塞的信号,等同于BLOCKED信号
        SigIgn: 0000000000001000          # 存放被忽略的信号,等同于IGNORED信号
        SigCgt: 00000001800004ec          # 存放捕获的信号,等同于CAUGHT信号
        CapInh: 0000000000000000          # 能够被当前进程执行的程序继承的能力
        CapPrm: 0000003fffffffff          # 表示进程能够使用的能力,在cap_permitted中可以包含cap_effective中没有的能力，这些能力是被进程自己临时放弃的,也可以说cap_effective是cap_permitted的一个子集
        CapEff: 0000003fffffffff          # 当一个进程要进行某个特权操作时,操作系统会检查cap_effective的对应位是否有效,而不再是检查进程的有效UID是否为0
        CapBnd: 0000003fffffffff          # 系统的边界能力,我们无法改变它.
        CapAmb: 0000000000000000
        NoNewPrivs:     0
        Seccomp:        0
        Speculation_Store_Bypass:       vulnerable
        Cpus_allowed:   f
        Cpus_allowed_list:      0-3
        Mems_allowed:   00000000,00000001
        Mems_allowed_list:      0
        voluntary_ctxt_switches:        56461 # 进程主动切换的次数
        nonvoluntary_ctxt_switches:     3352  # 进程被动切换的次数
4. meminfo

    cat /proc/meminfo: 查看整机内存使用情况的文件
    例子：
    
        MemTotal:        8169904 kB  # 所有内存(RAM)大小,减去一些预留空间和内核的大小                                                                                                                                            
        MemFree:          300088 kB  # 完全没有用到的物理内存，lowFree+highFree
        MemAvailable:     859032 kB  # 在不使用交换空间的情况下，启动一个新的应用最大可用内存的大小，计算方式：MemFree+Active(file)+Inactive(file)-(watermark+min(watermark,Active(file)+Inactive(file)/2))
        Buffers:           99476 kB  # 块设备所占用的缓存页，包括：直接读写块设备以及文件系统元数据(metadata)，比如superblock使用的缓存页。
        Cached:           655532 kB  # 普通文件数据所占用的缓存页
        SwapCached:            0 kB  # swap cache中包含的是被确定要swapping换页，但是尚未写入物理交换区的匿名内存页。那些匿名内存页，比如用户进程malloc申请的内存页是没有关联任何文件的，如果发生swapping换页，这类内存会被写入到交换区。
        Active:          7034000 kB  # 包含active anon和active file
        Inactive:         330284 kB  # 包含inactive anon和inactive file
        Active(anon):    6745716 kB  # anonymous pages（匿名页），用户进程的内存页分为两种：与文件关联的内存页(比如程序文件,数据文件对应的内存页)和与内存无关的内存页（比如进程的堆栈，用malloc申请的内存），前者称为file pages或mapped pages,后者称为匿名页。
        Inactive(anon):     6652 kB  # 见上
        Active(file):     288284 kB  # 见上
        Inactive(file):   323632 kB  # 见上
        Unevictable:           0 kB
        Mlocked:               0 kB
        SwapTotal:             0 kB  # 可用的swap空间的总的大小(swap分区在物理内存不够的情况下，把硬盘空间的一部分释放出来，以供当前程序使用)
        SwapFree:              0 kB  # 当前剩余的swap的大小
        Dirty:               136 kB  # 需要写入磁盘的内存去的大小
        Writeback:             0 kB  # 正在被写回的内存区的大小
        AnonPages:       6586056 kB  # 未映射页的内存的大小
        Mapped:           261216 kB  # 设备和文件等映射的大小
        Shmem:            147028 kB
        Slab:             379740 kB  # 内核数据结构slab的大小
        SReclaimable:     251520 kB  # 可回收的slab的大小
        SUnreclaim:       128220 kB  # 不可回收的slab的大小
        KernelStack:       10112 kB 
        PageTables:        47816 kB  # 管理内存页页面的大小
        NFS_Unstable:          0 kB  # 不稳定页表的大小
        Bounce:                0 kB
        WritebackTmp:          0 kB
        CommitLimit:     4084952 kB
        Committed_AS:   14682084 kB
        VmallocTotal:   34359738367 kB # Vmalloc内存区的大小
        VmallocUsed:           0 kB  # 已用Vmalloc内存区的大小
        VmallocChunk:          0 kB  # vmalloc区可用的连续最大快的大小
        Percpu:             4176 kB
        HardwareCorrupted:     0 kB
        AnonHugePages:   3352576 kB
        ShmemHugePages:        0 kB
        ShmemPmdMapped:        0 kB
        HugePages_Total:       0
        HugePages_Free:        0
        HugePages_Rsvd:        0
        HugePages_Surp:        0
        Hugepagesize:       2048 kB
        Hugetlb:               0 kB
        DirectMap4k:      522112 kB
        DirectMap2M:     7866368 kB
        DirectMap1G:     2097152 kB
