# 线程的几种写法

1. 原始
```
import threading
import time

def my_func(n):
    print('begin sleep: %s' % n)
    time.sleep(3)
    print('middle sleep: %s' % n)
    time.sleep(3)
    print('end sleep: %s' % n)

my_thread = threading.Thread(target=my_func, args=(n, lock))
my_thread.start()
print('before_join')
my_thread.join()   # 作用是阻塞，直到执行结束，如果没有这一行，就不会等待线程执行而直接往下走
print('end')
```

2. 类继承
```
class MyThread(threading.Thread):
    def __init__(self, n):
        super().__init__()
        self.n = n

    def run(self):
        my_func(self.n)

my_thread = MyThread(1)
my_thread.start()
print('before_join')
my_thread.join()
print('end')
```

3. 线程池
```
from concurrent.futures import FIRST_COMPLETED, wait
from concurrent.futures.thread import ThreadPoolExecutor

with ThreadPoolExecutor(max_workers=5) as t:
    all_task = [t.submit(my_func, n) for n in range(0, 10)]
    print('before_wait')
    wait(all_task, return_when=FIRST_COMPLETED)  # 作用和join类似，FIRST_COMPLETED - 第一个任务执行完就往下继续  ALL_COMPLETED - 所有任务执行结束才往下继续
    print('end')
```

### 思考：为什么实际项目中那些异步任务不使用线程去执行，线程开始之后不阻塞，而后客户端也不需要等待线程任务结束才得到返回数据，这样看起来线程和异步任务效果类似。

思考结论：项目中线程执行不可靠，项目进程可能会因为上线 or崩溃导致线程任务丢失，因为没有持久化，丢了的任务就再也找不回来了，这也是异步任务框架的意义了，对应重要的任务，还是必须保证成功率。不过非重要的任务感觉可以尝试下线程这种形式，不过和异步任务比起来可能会占用服务资源（我猜的），但是具体什么样还是需要实际验证了。
